car, cdr, roots

error archtiecture
	error sentinel & log

can it beat forth at the ease of primitive implementation?

C-level DSL in kreck
	
writing kreck interperter in kreck should be easier than in C
	macros

is iterating improper lists easy after all?

nil
	null pointer
		yay
			simpler iteration
			empty lists look like empty lists when printed naively
			less confusing
				is it?
				[to phil] is this question approachable in a good way?
		nay
	zero atom
		yay
			simpler predicates
		nay
			naive writer writes 0 for an empty list
			type "list of numbers or a number" impossible to define naively
				is that a problem?
	"nil" string pointer
		nay
			cumbersome
	"nil" symbol pointer?
		nay
			cumbersome
	how about version with bound checked atoms?

to define a type naively
	the instance of such type does not have metadata
	pock

		
atoms by pointer comparison?
	yay
		saves heap space
	nay
		possibly slower
			rly?
			it's one more reference to a cell, which may not be cached
				I expect them to be cached, they are used frequently
					for example when iterating over a list
				On archs with a lot of registers such as RISC-V I would
					even expect them to permanently sit in 2 registers
						Would they?
						are compilers smart enough?
						What about arm?
		I want atoms to be gc'd aswell
			"I want everything that I would find in normal lisp code to be GCd"
				strings & symbols
			external memory management for stuff like arithmetic would be a hassle


testing the gc
	examples should include
		trees where many pointers have the same value
		trees containing cells from different frames
	after the cleanup
		all cell pointed to by roots are in the current heap
		the trees are correct
		tree sizes are the same
			
nilfill
tree_size

kreck the wackiest
	what?
		if op is an atom, external fexpr call
		if op is a list, kreck function application
	why not function call atoms?
		The interpreter would be more complicated
		Fexprs generalize nicely
		Eval the fexpr's arguments and you get a function call
		Eval the result and you get a dynamic macro
	why not fexpr call closures then?	
		then it doesn't work as lisp and you'd have to put evals everywhere

[move to C style file?]
secondary return values passed as pointers with names ending in "_ret"
	yay
		I don't like structs as return values, too much clutter
		This way of doing things is ugly too, but oh well
	nay
		but it's confusing!


operator functions take subj and arglist and return flag

why is refcounting slower than snc?
	deallocation with refcounts needs to go through garbage

snc
	root_push(cell)
	root_pop(new_top)
returning?
roots are double pointers to cells
check implementations!
	something imperative
	lisp
	Haskell
just pop?
	cons automatically pushes a root
	but then functions manipulate roots not cells
root stack/link in asm

why bother with it in C/ASM?
just write an ABC collector and then write SnC in kreck

snc, but only roots in execution stack

"Root" can be a struct and store stuff like generation
	but what if 2 roots with different generations point to the same cell?

consing non-roots?
	atom
	just cons?
	cell_new?


qemu arm


static locals in asm
	addresses relative to instruction pointer

register machines aren't scary! you can just compile stupid code
that doesn't move stuff between registers

==================================================
OLD


testing for full heap inside gc function body or outside?
	inside
		condition is not duplicated in different functions that use 
			it shouldn't be!!! [unexpected refactor]
	outside

atoms are just address sized numbers
builtins and foreign functions are just atoms
kreck functions are just lists
pock + ldr, str, exe



should arithmetic operations be inner or outer?
what about floats?

should calling outer stuff be explicit?
	yay
		it's dangerous
	nay
		it's done often

interning

design principles
	pock but interacting with the machine

an easy to write natively, deep metaprogramming language

difference from pock
	metacircular evaluator with atomic ops?

write pock first, then do kreck

lispier?
	executing non-reserved atom causes lookup in the list stored at (car subject)
	yay
	nay

wackier?
	how?
		always exec atoms without evaling args
		evaling args must be compiled in the executed code

