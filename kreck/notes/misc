infinite loop test with SnC
	it seggies :(

separate preprocessing layer? 
	static macro expansion

definitions are kinda like let*

when are "let" bindings evaluated?

lazy let?

"let" is a preprocessing macro
	it appends new bindings to a symlist and expands the body using it

final code is name invariant


the flow of data when evaluating an expression using an internal system

definitions as threaded lets?

step back and think about the island?
	read the notes
	learn some hoon & haskell
			
constants, variables, identifiers

problem of substrings
	allocating new mem for new substring seems wasteful
		copying them even more so

[to phil?]
problems of wishy-washiness
	usually speed vs sanity

linking dependent definitions
a non-interning parser

concurrent parsing and conflicting symlists

"def" op interpreted by parser?
	yay
	nay
		clusterfuck

the master subject
	symlist

internal parsing
	subject updating?

keeping the old parser?
	needed for bootstrap

symbols can be locally bound aswell

new parser
	str, symlist ->  expr, str' symlist' ?
	stuff:rest symlist -> (assoc symlist stuff word_equal), rest, symlist'
	"stuff" -> string("stuff"); //the other stuff
	n=1A2B3C -> atom(&n, 3);

evaluation
	same as before, but with extra cdr
		rly???

what's opval then?
	opres

opname
opval
opres
	

do symbols really break layer separation?
	it's just a pair!
		is it really?

"noun" vs "a"?
	generic names can be 1 letter
	in opval or parse it should be "noun"
	in "noun_copy", each argument has different purpose
		what?
		contrast with "cons"
	how about when arguments with other types are present
		defadd
			should be value
				maybe even void pointer
		write?
			"a" seems sensible
				it's just a noun

ops with metadata
	it's just one more dereference when done naively
	might make debugging much easier	


using the heap to return pairs?
	yay
		not neading superficial structs
		more similar to the inner code
	nay
		slower
			hardly a problem?

parser that also generates a symlist
	yay
		heap can be smaller
	nay
		finding in list is O(n)
			hash tables can solve
		executable kreck doesn't preserve variable names
			should it?
				it would become lisp with a subject then
					would it be bad?

is interning necessary for internal parser?
	can't do hashes

how about interning using word-sized atoms?
	ugly?

fexpr variant can be made to differ by just one line
with ifdef to switch between them

kreck with
	fexpr inops
		(code . env) = *inop
		*(subj . (inop args)) = *((args . env) . code) //dots
	function inops
		(code . env) = *inop
		*(subj . (inop args)) = *((*/args . env) . code)
		

can internal macro be a fexpr?

macros with same syntax as fns/fexprs?
	I can always all them starting with a "!"
	& call fexprs starting with something else
		but non single char quote would look ugly

malloc as an exop in kreck?

keeping big stuff in the metaspace
	requires the big stuff to have deallocators
	it also requires the language to call the deallocators

counting snc collections in roots?
	only the number in the root with the lowest index matters
	but a program can return the higher root instead
	no, it can't be done


long atoms
	atom is a (sentinel . length) pair
	and the stuff [length] after it
	atoms are printed in hex by default

length in words or bytes?

printing without leading zeros
	find most significant word
	find most significant nibble
	print all significant nibbles


string problem
	parse to symbols?
		but the symbol list must still contain strings
	

making it usable
	repl
	source file reading
	server

internal deflist, internal parser

separating the interpreter from the rest

auras?

[on source edition clutter in C]

exop sets
	basic
		subj
		car
		cdr
		quot
		cons
		cond
		eval
		macro
	wordwise
		ldr
		str
		add
		sub
		mul
		div
		mod
		bit-not
		bit-and
		bit-or
		bit-xor



ops & defs
	another file?

multi-defines, internal defines, is using external deflist internally OK?

exop macros?

exop
	a fexpr...
	it's a fexpr and not a function to allow the ops to be general
inop
	a funcall
		it's funcall not fexp, to make expressions simple
	but don't I want generality from internal stuff also?
		buut that would require explicit evals in the closures
		and another call to put it in the subj
		and it would have to be done almost always, which is ugly
		but isn't it ugly for exops also?
			for inops it's just some calls appended on top of the code
			for exops it's a complicated expression with an eval
				is it really complicated?

an exop

a case for dynamic variable name resolution
		no need for auras
		might make things easier
	but
		shallower metaprogrammability 
			type system becomes external
			building an internal type system becomes ugly

less lispy kreck is simpler kreck
	only atomp
		or wordp
	0 atom is nil

car & cdr of atom & nil
	always error
		yay
		nay
	error for atom, nil for nil
		yay
		nay
	always nil
		yay
		nay


car, cdr, roots

error archtiecture
	error sentinel & log

can it beat forth at the ease of primitive implementation?

C-level DSL in kreck
	
writing kreck interperter in kreck should be easier than in C
	macros

is iterating improper lists easy after all?

nil
	null pointer
		yay
			one less LDR
			simpler iteration
			empty lists look like empty lists when printed naively
			less confusing
				is it?
				[to phil] is this question approachable in a good way?
		nay
			although nils are atoms, they have to be dealt with very differently
			since kreck is untyped, 
	zero atom
		yay
			simpler predicates
		nay
			naive writer writes 0 for an empty list
			type "list of numbers or a number" impossible to define naively
				is that a problem?
	"nil" string pointer
		nay
			cumbersome
	"nil" symbol pointer?
		nay
			cumbersome
	how about version with bound checked atoms?

to define a type naively
	the instance of such type does not have metadata
	pock

		
atoms by pointer comparison?
	yay
		saves heap space
	nay
		possibly slower
			rly?
			it's one more reference to a cell, which may not be cached
				I expect them to be cached, they are used frequently
					for example when iterating over a list
				On archs with a lot of registers such as RISC-V I would
					even expect them to permanently sit in 2 registers
						Would they?
						are compilers smart enough?
						What about arm?
		I want atoms to be gc'd aswell
			"I want everything that I would find in normal lisp code to be GCd"
				strings & symbols
			external memory management for stuff like arithmetic would be a hassle


testing the gc
	examples should include
		trees where many pointers have the same value
		trees containing cells from different frames
	after the cleanup
		all cell pointed to by roots are in the current heap
		the trees are correct
		tree sizes are the same
			
nilfill
tree_size

kreck the wackiest
	what?
		if op is an atom, external fexpr call
		if op is a list, kreck function application
	why not function call atoms?
		The interpreter would be more complicated
		Fexprs generalize nicely
		Eval the fexpr's arguments and you get a function call
		Eval the result and you get a dynamic macro
	why not fexpr call closures then?	
		then it doesn't work as lisp and you'd have to put evals everywhere

[move to C style file?]
secondary return values passed as pointers with names ending in "_ret"
	yay
		I don't like structs as return values, too much clutter
		This way of doing things is ugly too, but oh well
	nay
		but it's confusing!


operator functions take subj and arglist and return flag

why is refcounting slower than snc?
	deallocation with refcounts needs to go through garbage

qemu arm


static locals in asm
	addresses relative to instruction pointer

register machines aren't scary! you can just compile stupid code
that doesn't move stuff between registers

==================================================
OLD


testing for full heap inside gc function body or outside?
	inside
		condition is not duplicated in different functions that use 
			it shouldn't be!!! [unexpected refactor]
	outside

atoms are just address sized numbers
builtins and foreign functions are just atoms
kreck functions are just lists
pock + ldr, str, exe



should arithmetic operations be inner or outer?
what about floats?

should calling outer stuff be explicit?
	yay
		it's dangerous
	nay
		it's done often

interning

design principles
	pock but interacting with the machine

an easy to write natively, deep metaprogramming language

difference from pock
	metacircular evaluator with atomic ops?

write pock first, then do kreck

lispier?
	executing non-reserved atom causes lookup in the list stored at (car subject)
	yay
	nay

wackier?
	how?
		always exec atoms without evaling args
		evaling args must be compiled in the executed code

